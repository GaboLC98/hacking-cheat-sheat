#### XSS
### Definicion
XSS utiliza la mala sanitizacioon del input del usr para escribir codigo JavaScript en la pagina y que sea ejecutado del lado del cliente.
El funcionamiento es del lado del navegado. Si un usuario inserto codigo javascript, si otro ve ese codigo seria interpretado generando la ejecucion del mismo.
Hay tre tipos de XSS:
	-> Stored XSS
	-> RReflected XSS
	-> DOM-based XSS
Si bien los XSS hoy en dia no suelen salir del navegador y ejecutar codigo en el sistema, una vulnerrabilidad del navegador podria permitir que esto ocurra. Aun si, el impacto dentro del navegador puede ser alto en caso de robor de cookies por ejemplo.

### Stored XSS
Es la mas critica por la persistencia que se genera. El codigo, en estos casos, es almacenado een la base de datos, generando que siempre que se muestre la pagina donde see encuentrra el codigo, este sera interpretado.
La eliminacion del codigo no es simple, debe eliminarse directamente del backend.

##Testing payloads
<script>alert(window.origin)</script>
#Este prueba deberia general un cartel el navegador
-> Es simple de usar y es un payload basico que puede funcionar
-> Este payload puede ser bloqueado facilmente

<script>print()</script>
#Esta prueba nos mosotraria la vista previa de impresion de una hoja
-> Este puede no ser bloqueado

<script>alert(document.cookie)</script>
#Muestra la cookie

### Reflected XSS - No persistente
Esto se da cuando nuestro XSS impacta en el backend generando que haya una respuesta sin filtrar o sanitizarr.
Esto podemos probarlo cuando al ingrresar un input se noos devuelve un mensaje de error o de exito. Generalmente, si intentamos correr el <script></script> del ejemplo anterior, este funcionaria y en el mensaje de error o exito podriamos ver '' en donde iria nuestro output.
-> Al no ser persistente, si la pagina se reecarga el mensaje no volveria a aparecer.
Al no ser persistente, si queremos realizar el ataque a un usuario debemoos prestar atencion como se manda nueestro input. Si es un GET este viaja en la URL, con solo mandarle la URL y el GET XSS el usuario estaria ejecutando el XSS.

### DOM XSS - No persistente
En reflected el XSS es enviado al servidor, en DOM, el XSS es interpretado de forma completa por el cliente mediante JavaScript.
Cuando nuestro input es agregado en la URL pero con un # (ej: ?#task=test) quiere decir que el input es procesado en el lado del cliente mediante JavaScript y no llega al backend.
El problema se da cuando sink escribe nuestro input en un objeto DOM sin sanitizar. 
-> Source y sink: SOURCE es el objeto JavaScript que toma nuestro imput (parametro url, input field, etc); Por otro lado SINK escribe un objeto DOM con el input que recibio SOURCE.

Funciones coomunes para escibir objetos DOM
	document.write()
	DOM.innerHTML
	DOM.outerHTML
Algunas funciones de la libreria JQuery que escriben DOM
	add()
	after()
	append()

Por lo gral estas funciones pueden ser vistas en un script.js siendo llamadas como .innerHTML, .outerHTML, etc

Para estos casos es recomendable usar otrro tipo de payloads de pruebba
<img src="" onerror=alert(window.origin)>
#Este payload crea una nueva imagen HTML que posee el atributo onerror que se ejecuta cuando la imagen no es encontrada. Funciona como el <script>

### Descubrimiento de XSS
Todo lo anterior puedee ser una forrma de entender e intentar descubir un XSS. Aun asi existen erramientas que nos ayudan a encontrarlo.
Algunos tools que sirven ademas de Burp pro y Nessus son XSS Strike, Brute XSS, and XSSer.

## XSS Strike
git clone https://github.com/s0md3v/XSStrike.git
pip install -r requirements.txt
python xsstrike.py -u "URL"
-> La url debe contener los parmetros (?xx=xx)

## Testeos manuales
Por payloads consultar: PayloadAllTheThings o PayloadBox
Aun asi, no siempre los payloads van a servirnos y se puede perder bastante tiempo probando uno a uno.
La forma manual mas eficiente es revisar el codigo para entender como es tratado nuestro input y asi crear un payload. De esta forma, evitamos la perdida de tiempo que puede llegar a causar payloads basicos y conocidos como a su vez tools ya que los desarrolladores corren en sus paginas web tools para identificar vulnerabilidades y asi arreglarlo.

